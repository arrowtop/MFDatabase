/*************************************************************************************************
 * CS 562 Project 
 * Author: Yujie Du(10372723), Chuanhui Zhang(10387654)
 * 
 * MFMainMinLoopGenerator class is used to generator the main class to implement the query.
 * This class is used to generator the main function to response user's query.
 * The function generated is called MFMain.
 * To create an instance of this class, you need a path to save the output file,
 * you also need MFStructure's information to build scan loop and collect data needed
 * and you also need Database Manager to get the information of the Database information, like schema.
 * 
 * This class will generate the MFMain class with Minimum Loops!
 * 
 *************************************************************************************************/

package imagineDragon;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Stack;


public class MFMainMinLoopGenerator {
	
	private String path; // Location to save output file.	
	private String code; // Final output string as a whole.	
	private boolean isOutputOnUI;//whether output on the InputUI or not
	private TopologicalSortWithUpdate tswu;
	
	//****The variables below are all static variables that should be appear in the class generated.*****/
	private static String importInfo = "import java.sql.*;\n"  // Package needed in output file
											+ "import java.util.HashMap;\n"
											+ "import java.util.Map.Entry;\n"
											+ "import java.util.Iterator;\n"
											+ "import java.util.Map;\n\n";	
	private static final String classFrame = "public class MFMain {\n\n";	
	private static final String mainFrame = 
			"\n\n\tstatic public void main(String[] args) {\n\n";
	private static final String varDeclaration = 
			"\t\tMap<String, MFStruct> mapMFStruct = new HashMap<String, MFStruct>();\n";
	private static final String dbConnect = "\t\t" + "try\n" + "\t\t{\n"
											+ "\t\t\tClass.forName(DBDRIVER);\n"
											+ "\t\t\tconn = DriverManager.getConnection(DBURL, DBUSER, DBPASSWORD);\n";
	private static final String fetchAllQuery = "\t\t\trs = stmt.executeQuery(sql);\n";
	private static final String exceptions = "\t\t}\n"
										+ "\t\tcatch (SQLException e) {\n"
										+ "\t\t\te.printStackTrace();\n"
										+ "\t\t}catch(ClassNotFoundException e) {\n"
										+ "\t\t\te.printStackTrace();\n"
										+ "\t\t}\n";
	private static final String end = "\t}\n"
										+ "}\n";
	//*****************************************************************************************************/
	
	MFMainMinLoopGenerator(String path, MFStructInfo mfsi, DatabaseManager dm, TopologicalSortWithUpdate tswu, boolean isOutputOnUI){
		
		this.path = path; //Location to save output file
		this.tswu = tswu;	
		this.isOutputOnUI = isOutputOnUI;
		//Database connection information including variables like Driver, url, user name and password;
		//besides, there are also some static String to build database connection.				
		String driver = "org.postgresql.Driver";
		String tableName = "sales";	
		//DataConnection information needed	
		String dbInfomation = "\t//Information needed to connect to database by using jdbc.\n"
							+ "\tprivate static final String DBDRIVER = \"" + driver + "\";\n"
							+ "\tprivate static final String DBURL = \"" + dm.getUrl() + "\";\n"
							+ "\tprivate static final String DBUSER = \"" + dm.getUsr() + "\";\n"
							+ "\tprivate static final String DBPASSWORD = \"" + dm.getPwd() + "\";\n"
							+ "\tstatic Connection conn;\n";;		
		String fetchAllSQL =  "\t\t\tString sql = \"SELECT * FROM " + tableName + "\";\n"
								+ "\t\t\tStatement stmt = conn.createStatement();\n"
								+ "\t\t\tResultSet rs;\n";
		//To build while loop
		String scanLoopInfo = ScanMinLoopInfo(mfsi);
		//To build printout result of query
		String printOutInfo = PrintOutInfo(mfsi);
		
		SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		// Comments and package belonged to to output
		String classComment = "/*************************************************************************************************\n"
				+ "* CS 562 Project\n" 
				+ "* Author: Yujie Du(10372723), Chuanhui Zhang(10387654)\n"
				+ "*\n" 
				+ "* This class is generated by MFMainGenerator(), generated at " + df.format(new Date()) + "\n"
				+ "* It will require the data from MFStruct class which is generated by MFStructGenerator class.\n"
				+ "*\n" 
				+ "*************************************************************************************************/\n\n"				
				+ "package imagineDragon;\n\n";
		if(this.isOutputOnUI == true) {
			importInfo = "import java.sql.*;\n"  // Package needed in output file
					+ "import java.util.HashMap;\n"
					+ "import java.util.Map.Entry;\n"
					+ "import java.util.Iterator;\n"
					+ "import java.util.Map;\n"
					+ "import java.io.ByteArrayOutputStream;\n"
			        + "import java.io.PrintStream;\n\n";
		}
		
		this.code = classComment + importInfo + classFrame + dbInfomation + mainFrame
				  + varDeclaration + dbConnect + fetchAllSQL + scanLoopInfo + printOutInfo + exceptions + end;
	}
	
	/**
	 * Print-out information depends on user's query
	 * @param mfsi MFStructure
	 * @return String of printout
	 */
	public String PrintOutInfo(MFStructInfo mfsi){
		String outputOnUI = "";
		if(isOutputOnUI == true) {
			outputOnUI += "\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n"
			             + "\t\t\tPrintStream ps = new PrintStream(baos);\n"
			             + "\t\t\tPrintStream old = System.out;\n"
			             + "\t\t\tSystem.setOut(ps);\n";
		}
		String printOutInfo = "\t\t\t//Print out result of user's query.\n"
		                    + "\t\t\t\tSystem.out.printf(\"";
		String selAttrType = "";				
		String selAttrName = "";
		String selAttr = "";
		String selVariable = "";
		Map<String, Boolean> selAttrMap = mfsi.getSelAlignMap();
		Map<String,String> selAttrsType = mfsi.getAfNameToTypeMap();
		Map<String, ArrayList<String>> selectAttrMap = mfsi.getSelectMap();
		HashSet<String> svSet = new HashSet<String>();
		
		for(String s : mfsi.getSelAttrList()){
			selAttrName += "\""+ s +"\", ";
			ArrayList<String> selectVariables = selectAttrMap.get(s);
			selAttr += "\t\t\t\t";
			if(!selAttrsType.containsKey(selectVariables.get(0))) {
				selAttr += "val.get_" + s + "(),\n";
			}
			else{
				String type = selAttrsType.get(selectVariables.get(0));
				
				if(type.equals("String")) selAttr += "val.get_" + s + "(),\n";

				for(String sv: selectVariables) {
					if(!svSet.contains(sv)) {
						selVariable += "\t\t\t\t" + type + " " + sv + " = " + "val.get_" + sv + "();\n";
						svSet.add(sv);
					}
					switch(type) {
						case "int": 
							selAttr += sv + " == Integer.MAX_VALUE"
									+ "||" + sv + " == Integer.MIN_VALUE||";
							break;
						case "float":
							selAttr += sv + " == Float.MAX_VALUE"
									+ "||" + sv + " == Float.MIN_VALUE||";
							break;
						case "double":
							selAttr += sv + " == Double.MAX_VALUE"
									+ "||" + sv + " == Double.MIN_VALUE||";
							break;
						
					}
				}
				if(!type.equals("String")) {
					selAttr = selAttr.substring(0, selAttr.length()-2);
					selAttr += "?\"\":" + s + ",\n";
				}			
			}
			selAttrType += "|%" + (selAttrMap.get(s)==true?"":"-") + (s.length()/14 + 1)*14 + "s";
					
		}	
		selAttrType += "|\\n\", ";
		selAttrName = selAttrName.substring(0, selAttrName.length()-2);
		selAttr = selAttr.substring(0, selAttr.length()-2) + " );\n";
		
		String iterDecalaration = "\t\t\tIterator<Entry<String, MFStruct>> iter = mapMFStruct.entrySet().iterator();\n";
				
		String outputLoop = "\t\t\twhile(iter.hasNext()){\n"
				+"\t\t\t\tMap.Entry entry = (Map.Entry) iter.next();\n"
				+ "\t\t\t\tMFStruct val = (MFStruct)entry.getValue();\n";
		outputLoop += selVariable;
		outputLoop += "\t" + printOutInfo + selAttrType + "\n";
		String endOutputLoop = "\t\t\t}\n";
		if(isOutputOnUI == true) {
			endOutputLoop += "\t\t\tSystem.out.flush();\n"    
						  + "\t\t\tSystem.setOut(old);\n"
			              + "\t\t\tInputUI.setTextAreaSE(baos.toString());\n"
						  + "\t\t\tSystem.out.println(baos.toString());\n";
		}
		
		printOutInfo = outputOnUI + printOutInfo + selAttrType.replaceAll("-", "") + selAttrName + " );\n"
						+ iterDecalaration + outputLoop + selAttr +endOutputLoop; 
		return printOutInfo;
	}	
	/**
	 * While loop and data of attributes to be computed
	 * @param mfsi	MFStructure
	 * @return	String of While loop
	 */
	public String ScanMinLoopInfo(MFStructInfo mfsi){
		String scanLoopInfo ="\t\t\t//By scanning the table to get the value of attribute needed.\n";
		Map<Integer, HashSet<Integer>> schedule = tswu.getSchedule();
		int loopTime = schedule.size();  //Times of loop needed
		for(int i = 0; i < loopTime; i++){
			HashSet<Integer> currSchedule = schedule.get(i);
			Map<String, String> schemaInfo = mfsi.getSchemaInfo();	//Schema information <attributeName, dataType>
			Iterator<Entry<String, String>> iter0 = schemaInfo.entrySet().iterator();
			String attrList = "";
			while (iter0.hasNext()){
			 	Map.Entry entry = (Map.Entry) iter0.next();
				Object key = entry.getKey();
				Object val = entry.getValue();
				Object tempVal = val;
				if(val == "int"){
					tempVal = "Int";
				}
				//For example: int quant = rs.getInt("quant")
				attrList += "\t\t\t\t" + val + " " + key + " = rs.get" + tempVal + "(\"" + key + "\");\n";  
			}
			
			Map<String, String> attrMap = mfsi.getGaNameToTypeMap(); //Use group attributes to build key for map
			Iterator<Entry<String, String>> iter1 = attrMap.entrySet().iterator(); 
			String groupAttr = "";
			String mfstruct = "";
			while (iter1.hasNext()) { 
			    Map.Entry entry = (Map.Entry) iter1.next();
			    Object key = entry.getKey();
			    groupAttr += key + " + ";
			    mfstruct += key + ", ";
			} 
			groupAttr = groupAttr.substring(0, groupAttr.length()-3);
			mfstruct = mfstruct.substring(0, mfstruct.length()-2);
			String mapKey = "\t\t\t\t" + "String key = \"\" + " + groupAttr + ";\n"; //Build the key for map
			String isKeyExist =   "\t\t\t\t\t" + "if(!mapMFStruct.containsKey(key)){\n"		//if the group attributes already exist, jump or create one
							+ "\t\t\t\t\t\t" + "MFStruct mfstruct = new MFStruct(" + mfstruct + ");\n";
			
			
			
			String scanLoopInfo_inner;  //Build the while loop to scan the table
			String startWhile = "\t\t\twhile(rs.next()) {\n";
			scanLoopInfo += fetchAllQuery + startWhile + attrList + mapKey;
			HashSet<String> checkDefineAggr = new HashSet<String>();
			for(int currentLoop : currSchedule) {//Current loop
			Map<Integer, ArrayList<String>> condMap = mfsi.getCondMap();  //If the loop appears in map, check dependency, or not
			if(condMap.containsKey(currentLoop)){
				/*****************Generate dependency aggregate function******************/
				//String dependAggrFunListModule = "\t\t\t\tArrayList<String> dependAggrFunList = new ArrayList<String>();\n";
				ArrayList<String> dependList = condMap.get(currentLoop);
				
				/*****************Is the value of aggregate function valid?*********/
				Map<String,String> aggrTypeMap = mfsi.getAfNameToTypeMap();
				String defineAggr = "";
				String aggrFunStructure = "";
				int aggrFunLoop = 0;
				for(Iterator<String> iter = dependList.iterator(); iter.hasNext();) {
					String getAggrFunValue = "";	
					String isValidOfAggrFunValue ="";
					String aggrName = iter.next();					
					String aggrType = aggrTypeMap.get(aggrName);
					String initialValue1 = "";
					String initialValue2 = "";
					//Assigning the initial value depends data type
					switch(aggrType){
						case "int":
							initialValue1= "Integer.MAX_VALUE";
							initialValue2 = "Integer.MIN_VALUE";
							break;
						case "double":
							initialValue1 = "Double.MAX_VALUE";
							initialValue2 = "Double.MIN_VALUE";
							break;
						case "float":
							initialValue1 = "Float.MAX_VALUE";
							initialValue2 = "Float.MIN_VALUE";
							break;
						case "String":
							initialValue1 = "\"\"";
							initialValue2 = "\"\"";
							break;
						
						default:
							break;
					}
					if(!checkDefineAggr.contains(aggrName)) {
						String initValue = aggrType.equals("String")? "\"\"":"0";
						defineAggr += "\t\t\t\t" + aggrType + " " +aggrName + " = " + initValue +";\n";
						checkDefineAggr.add(aggrName);
					}
					getAggrFunValue += "\t\t\t\t\t";
					getAggrFunValue += aggrType + " ";
					String aggrFunValue = "aggrFunValue" + aggrFunLoop;
					getAggrFunValue += aggrFunValue + "= mapMFStruct.get(key).get_"+ aggrName +"();\n";
					if(!aggrType.equals("String")) {
						isValidOfAggrFunValue += "\t\t\t\t\tif(" + aggrFunValue + "== "+initialValue1+"|| " + aggrFunValue + " == "+ initialValue2 +"){\n";
					} else {
						isValidOfAggrFunValue += "\t\t\t\t\tif(" + aggrFunValue + ".equals("+initialValue1+")){\n";
					}
					isValidOfAggrFunValue +="\t\t\t\t\t\tcontinue;\n"
							+"\t\t\t\t\t}else{\n"
							+ "\t\t\t\t\t\t" +aggrName +" = "+aggrFunValue + ";\n"
							+ "\t\t\t\t\t}\n";
					aggrFunStructure += getAggrFunValue + isValidOfAggrFunValue;
					aggrFunLoop++;
				}
				String isExistInMFStructure = defineAggr+"\n\t\t\t\tif(mapMFStruct.containsKey(key)){\n";			
				scanLoopInfo_inner = isExistInMFStructure + aggrFunStructure +"\t\t\t\t}\n"
						+ "\n\t\t\t\tif( " + mfsi.getCondList().get(currentLoop) + " ){\n";
			}else{
				scanLoopInfo_inner = "\n\t\t\t\tif( " + mfsi.getCondList().get(currentLoop) + " ){\n";
			}
			
			/****************************Set the value to MFStructure****************************************/
			Map<String,Stack<String>> aggrFun = mfsi.getAfCoreList().get(currentLoop + "");
			Iterator<Entry<String, Stack<String>>> iter2 = aggrFun.entrySet().iterator();
			String mfstructSet = "";
			while (iter2.hasNext()) { 
			    Map.Entry entry = (Map.Entry) iter2.next(); 
			    Object key = entry.getKey(); 
			    Stack<String> val = (Stack<String>) entry.getValue(); 
			    while(!val.empty()){
			    	String attr = val.pop();
			    	mfstructSet += "\t\t\t\t\t\t" + "mfstruct.set_" + key +"_" + currentLoop + "_" + attr + "(" + attr + ");\n";
			    }
			} 
										
			String inMap =  "\t\t\t\t\t\t" + "mapMFStruct.put(key, mfstruct);\n"
						+ "\t\t\t\t\t" + "}else{\n"
						+ "\t\t\t\t\t\t" + "MFStruct mfstruct = mapMFStruct.get(key);\n";
						
			String res = "\t\t\t\t\t\t" + "mapMFStruct.put(key, mfstruct);\n" 
						+"\t\t\t\t\t" + "}\n"
						+"\t\t\t\t}\n";
			
			
			scanLoopInfo += scanLoopInfo_inner + isKeyExist + mfstructSet + inMap + mfstructSet + res;
			}
			String end = "\t\t\t}\n";
			scanLoopInfo += end;
		}
		
		return scanLoopInfo;
	}
	
	/**
	 * Entry of MFMainGenerator class
	 * @return if succeed, return true.
	 */
	boolean run(){
		PrintWriter pwoutMain = null;
		try {
			pwoutMain = new PrintWriter(new FileWriter(path + "/MFMain.java"));			
		} catch (IOException e) {
			e.printStackTrace();
		}
		//System.out.println(code);
		pwoutMain.print(code);
		pwoutMain.close();
		return true;
	}

}